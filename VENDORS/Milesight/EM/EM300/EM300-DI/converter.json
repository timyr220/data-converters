{
  "name": "converter",
  "type": "UPLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": null,
    "tbelDecoder": "var data = decodeToJson(payload);\nvar deviceName = data.deviceInfo.deviceName;\nvar deviceType = data.deviceInfo.deviceProfileName;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodePayload(inputArray) {\n    var output = {attributes: {}, telemetry: {}};\n    // --- Decoding code --- //\n    var input = bytesToExecutionArrayList(inputArray);\n    output.telemetry.HEX_bytes = bytesToHex(input);\n\n    var decoded = {};\n    decoded.hexString = bytesToHex(input);\n\n    for (var i = 0; i < input.length - 3;) {\n        var channel_id = input[i++] & 0xff;\n        var channel_type = input[i++] & 0xff;\n\n        // BATTERY\n        if (channel_id === 0x01 && channel_type === 0x75) {\n            decoded.battery = input[i++] & 0xff;\n        }\n        // TEMPERATURE\n        if (channel_id == 0x03 && channel_type == 0x67) {\n            decoded.temperature = parseBytesToInt(input, i, 2, false) / 10;\n            i += 2;\n        }\n        // HUMIDITY\n        if (channel_id === 0x04 && channel_type === 0x68) {\n            decoded.humidity = (input[i++] & 0xff) / 2.0;\n        }\n        // GPIO\n        else if (channel_id === 0x05 && channel_type === 0x00) {\n            decoded.gpio = input[i++] & 0xff;\n        }\n        // GPIO -> PULSE COUNTER\n        else if (channel_id === 0x05 && channel_type === 0xc8) {\n            decoded.pulse = parseBytesToInt(input, i, 4, false);\n            i += 4;\n        }\n        // Water\n        else if (channel_id === 0x05 && channel_type === 0xe1) {\n            decoded.water_conv = parseBytesToInt(input, i, 2, false) / 10;\n            decoded.pulse_conv = parseBytesToInt(input, i + 2, 2, false) / 10;\n            decoded.water = parseBytesIntToFloat(input, i + 4, 4, false);\n            i += 8;\n        }\n        // GPIO ALARM\n        else if (channel_id === 0x85 && channel_type === 0x00) {\n            decoded.gpio = readGPIOStatus(input[i] & 0xff);\n            decoded.gpio_alarm = readGPIOAlarm(input[i + 1] & 0xff);\n            i += 2;\n        }\n        // WATER ALARM\n        else if (channel_id === 0x85 && channel_type === 0xe1) {\n            decoded.water_conv = parseBytesToInt(input, i, 2, false) / 10;\n            decoded.pulse_conv = parseBytesToInt(input, i + 2, 2) / 10;\n            decoded.water = parseBytesIntToFloat(input, i + 4, 4);\n            decoded.water_alarm = readWaterAlarm(input[i + 8] & 0xff);\n            i += 9;\n        }\n\n        // HISTORICAL DATA\n        else if (channel_id === 0x20 && channel_type === 0xCE) {\n            var timestamp = parseBytesToInt(input, i, 4, false);\n            var values = {};\n            values.temperature = parseBytesToInt(input, i+4, 2, false);\n            values.humidity = input[i + 6] & 0xff;\n            values.gpio_type = readGPIOType(input[i + 7] & 0xff);\n            values.gpio = readGPIOStatus(input[i + 8] & 0xff);\n            values.pulse =  parseBytesToInt(input, i+9, 4, false);\n\n            i += 13;\n            if (decoded.history === null) {\n                decoded.history = [];\n            }\n            var dataWitTs = {\n                \"ts\": timestamp,\n                \"values\": values\n            };\n            decoded.history.push(dataWitTs);\n        }\n        // HISTORICAL DATA2\n        else if (channel_id === 0x21 && channel_type === 0xCE) {\n            var timestamp2 = parseBytesToInt(input, i, 4, false);\n\n            var values2 = {};\n            values2.temperature = parseBytesToInt(input, i+4, i+6, false);\n            values2.humidity = input[i + 7] & 0xff;\n            values2.alarm = readAlarmHistory(input[i + 8] & 0xff);\n            values2.gpio_type = readGPIOType(input[i + 9] & 0xff);\n            values2.gpio = readGPIOStatus(input[i + 10] & 0xff);\n            values2.water_conv =  parseBytesToInt(input, i+10, i+12, false);\n            values2.pulse_conv =  parseBytesToInt(input, i+12, i+14, false);\n            values2.water = parseBytesToInt(input, i+14, i+18, false);\n\n            i += 18;\n            if (decoded.history === null) {\n                decoded.history = [];\n            }\n            var dataWitTs = {\n                \"ts\": timestamp2,\n                \"values\": values2\n            };\n            decoded.history.push(dataWitTs);\n        }\n\n    }\n    if (decoded.?history.size() > 0) {\n        output.history = decoded.history;\n        decoded.remove(\"history\");\n    }\n    output.telemetry = decoded;\n    return output;\n}\n\nfunction readGPIOStatus(input) {\n    // 0: low, 1: high\n    switch (input) {\n        case 0:\n            return \"low\";\n        case 1:\n            return \"high\";\n        default:\n            return \"unknown\";\n    }\n}\n\nfunction readGPIOType(input) {\n    // 1: gpio, 2: pulse\n    switch (input) {\n        case 1:\n            return \"gpio\";\n        case 2:\n            return \"pulse\";\n        default:\n            return \"unknown\";\n    }\n}\nfunction readGPIOAlarm(input) {\n    switch (input) {\n        case 0:\n            return \"gpio alarm release\";\n        case 1:\n            return \"gpio alarm\";\n        default:\n            return \"unknown\";\n    }\n}\n\nfunction readWaterAlarm(input) {\n    // 1: water outage timeout alarm, 2: water outage timeout alarm release, 3: water flow timeout alarm, 4: water flow timeout alarm release\n    switch (input) {\n        case 1:\n            return \"water outage timeout alarm\";\n        case 2:\n            return \"water outage timeout alarm release\";\n        case 3:\n            return \"water flow timeout alarm\";\n        case 4:\n            return \"water flow timeout alarm release\";\n        default:\n            return \"unknown\";\n    }\n}\n\n\nfunction readAlarmHistory(input) {\n    // 0: none, 1: water outage timeout alarm, 2: water outage timeout alarm release, 3: water flow timeout alarm, 4: water flow timeout alarm release, 5: gpio alarm, 6: gpio alarm release\n    switch (input) {\n        case 0:\n            return \"none\";\n        case 1:\n            return \"water outage timeout alarm\";\n        case 2:\n            return \"water outage timeout alarm release\";\n        case 3:\n            return \"water flow timeout alarm\";\n        case 4:\n            return \"water flow timeout alarm release\";\n        case 5:\n            return \"gpio alarm\";\n        case 6:\n            return \"gpio alarm release\";\n        default:\n            return \"unknown\";\n    }\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.time;\nvar timestamp = -1;\nif (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n        var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n        var millisecondsEndIndex = dateString.lastIndexOf('+');\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('Z');\n        }\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('-');\n        }\n        if (millisecondsEndIndex == -1) {\n            if (dateString.length >= secondsSeparatorIndex + 3) {\n                dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n            }\n        } else {\n            dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n                dateString.substring(millisecondsEndIndex, dateString.length);\n        }\n        timestamp = new Date(dateString).getTime();\n    }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.deduplicationId = data.deduplicationId;\n\n// You can exclude some keys from the result\nvar excludeFromAttributesList = [\"deviceName\", \"rxInfo\", \"confirmed\", \"data\", \"deduplicationId\", \"time\", \"adr\", \"dr\", \"fCnt\"];\nvar excludeFromTelemetryList = [\"data\", \"deviceInfo\", \"txInfo\", \"devAddr\", \"adr\", \"time\", \"fPort\", \"region_common_name\", \"region_config_id\", \"deduplicationId\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found.\n\nvar telemetryData = toFlatMap(data, excludeFromTelemetryList, false);\nvar attributesData = toFlatMap(data, excludeFromAttributesList, false);\n\nvar uplinkDataList = [];\n\n// Passing incoming bytes to decodePayload function, to get custom decoding\nvar customDecoding = decodePayload(base64ToBytes(data.data));\n\nvar telemetries;\ntelemetry.putAll(telemetryData);\n// Collecting data to result\nvar telemetryValues = {};\nif (customDecoding.?telemetry.size() > 0) {\n    telemetryValues = {\n        ts: timestamp,\n        values: telemetry\n    };\n    telemetry.putAll(customDecoding.telemetry);\n}\n\n\nif (customDecoding.?history.size() > 0) {\n    telemetries = customDecoding.history;\n    if (telemetryValues.size() > 0) {\n        telemetries.push(telemetryValues);\n    }\n} else {\n    telemetries = telemetryValues;\n}\n\nattributes.putAll(attributesData);\n\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: telemetries\n};\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "deviceProfileId",
      "deviceProfileName",
      "devEui",
      "devAddr",
      "fPort",
      "frequency",
      "bandwidth",
      "spreadingFactor",
      "codeRate",
      "battery",
      "pir",
      "daylight",
      "confirmed",
      "gatewayId",
      "channel",
      "rfChain",
      "crcStatus"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}